<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
  <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
  <meta name="screen-orientation" content="landscape">
  <title>John Paul Showdown🔥</title>
  <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@600&display=swap" rel="stylesheet">
  <style>
  :root {
    --btn-size: clamp(50px, 18vw, 70px);
  }

  body {
    margin: 0;
    padding: 0;
    font-family: 'Orbitron', sans-serif;
    background: radial-gradient(circle at center, #222, #000);
    color: white;
    user-select: none;
    overflow-x: hidden;
    overflow-y: auto;
    touch-action: manipulation;
  }

  /* Base canvas size (already mostly responsive) */
canvas {
  width: 95vw;
  max-width: 800px;
  height: auto;
  aspect-ratio: 2 / 1;
  border: 3px solid #fff;
  border-radius: 12px;
  background: linear-gradient(to bottom, #333, #111);
  touch-action: none;
  margin: 10px auto;
}

/* Controls container base */
#controls {
  display: flex;
  flex-direction: column;
  align-items: center;
  margin-top: 10px;
  gap: 20px;
  padding: 0 10px;
}

/* Controls rows */
.buttons-row {
  display: flex;
  gap: 12px;
  flex-wrap: wrap;
  justify-content: center;
  margin: 6px 0;
}

/* Landscape styles */
@media (orientation: landscape) and (max-width: 1024px) {
  /* Make body full height with no overflow on X */
  body {
    overflow-x: hidden;
  }

  /* Resize canvas for landscape */
  canvas {
    width: 70vw;
    max-width: 1000px;
    height: auto;
    aspect-ratio: 2 / 1;
  }

  /* Controls layout changes for landscape */
  #controls {
    flex-direction: row;
    justify-content: space-around;
    align-items: flex-end;
    gap: 15px;
    padding: 0 15px;
  }

  /* Player controls side by side */
  .player-controls {
    flex: 1;
    display: flex;
    flex-direction: column;
    align-items: center;
  }

  /* Buttons row wraps less in landscape */
  .buttons-row {
    flex-wrap: nowrap;
    justify-content: center;
  }

  /* Increase button size for easier tapping */
  button {
    min-width: 60px;
    min-height: 60px;
    font-size: clamp(16px, 5vw, 22px);
    padding: 14px;
  }

  /* Volume slider wider */
  #volumeSlider {
    width: 40vw;
    max-width: 400px;
  }
}

/* Portrait orientation (default, but just in case) */
@media (orientation: portrait) {
  #controls {
    flex-direction: column;
    align-items: center;
  }

  .player-controls {
    margin-bottom: 15px;
  }
}
</style>
</head>
<body>

<!-- Title Screen -->
<div id="titleScreen">
  <h1>🔥 JOHN PAUL SHOWDOWN 🔥</h1>
  <form id="playerForm">
  <select id="gameMode" style="padding:10px;margin-bottom:10px;font-size:16px;border-radius:6px;">
  <option value="pvp">👥 Player vs Player</option>
  <option value="ai">🤖 Player vs AI</option>
</select><br>

<!-- New Difficulty Selector -->
<div id="difficultyWrapper" style="display:none; margin-top:10px;">
  <label for="aiDifficulty">🎚️ Difficulty:</label>
  <select id="aiDifficulty" style="padding:8px;margin-top:5px;font-size:15px;border-radius:6px;">
    <option value="easy">🟢 Easy</option>
    <option value="medium" selected>🟡 Medium</option>
    <option value="hard">🔴 Hard</option>
  </select>
</div>

  <input type="text" id="player1Name" placeholder="Player 1 Name" required style="padding:10px;font-size:16px;margin:5px;border-radius:6px;" />
  <input type="text" id="player2Name" placeholder="Player 2 Name" required style="padding:10px;font-size:16px;margin:5px;border-radius:6px;" />
  <br>
  <button type="submit" style="padding:10px 20px;margin-top:10px;font-size:18px;border-radius:6px;background:#f39c12;color:#000;font-weight:bold;cursor:pointer;">
    Start Game 🚀
  </button>
</form>

</div>

<!-- Game Canvas -->
<main>
  <canvas id="gameCanvas" width="800" height="400" aria-label="Stickman Showdown Game"></canvas>
</main>

<!-- Controls UI -->
<section id="controls" aria-label="Game Controls">
  <!-- Player 1 Controls -->
  <div class="player-controls" aria-label="Player 1 Controls">
    <h3 style="color:#e63946;">Player 1</h3>
    <div class="buttons-row">
      <button id="p1-left" aria-label="Player 1 Left">◀️</button>
      <button id="p1-right" aria-label="Player 1 Right">▶️</button>
      <button id="p1-ultimate" style="background:gold;color:black;font-weight:bold;display:none;">💥 Ultimate</button>
    </div>
    <div class="buttons-row">
      <button id="p1-jump" aria-label="Player 1 Jump">🔼 Jump</button>
      <button id="p1-punch" class="punch-btn p1" aria-label="Player 1 Punch">👊 Punch</button>
    </div>
  </div>

  <!-- Player 2 Controls -->
  <div class="player-controls" aria-label="Player 2 Controls">
    <h3 style="color:#457b9d;">Player 2</h3>
    <div class="buttons-row">
      <button id="p2-left" aria-label="Player 2 Left">◀️</button>
      <button id="p2-right" aria-label="Player 2 Right">▶️</button>
      <button id="p2-ultimate" style="background:gold;color:black;font-weight:bold;display:none;">💥 Ultimate</button>
    </div>
    <div class="buttons-row">
      <button id="p2-jump" aria-label="Player 2 Jump">🔼 Jump</button>
      <button id="p2-punch" class="punch-btn p2" aria-label="Player 2 Punch">👊 Punch</button>
    </div>
  </div>
</section>

<!-- Volume Control -->
<div id="volumeControl">
  🔊 Volume: <input type="range" id="volumeSlider" min="0" max="1" step="0.01" value="0.3" />
</div>

<!-- Game Over Overlay -->
<div id="gameOverOverlay" role="alert" aria-live="assertive"></div>

<!-- Audio -->
<audio id="bgMusic" src="background.mp3" loop preload="auto"></audio>
<audio id="punchSound" src="punch.mp3" preload="auto"></audio>
<audio id="koSound" src="ko.mp3" preload="auto"></audio>

<!-- Game Script -->
<script>

  // Prevent scrolling on iOS when touching buttons
document.body.addEventListener('touchmove', function (e) {
  if (e.target.tagName === 'BUTTON') e.preventDefault();
}, { passive: false });

let aiDifficulty = "medium";
let player1Name = "Player 1";
let player2Name = "Player 2";
let gameMode = "pvp"; // default
let isAI = false;

const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const ground = canvas.height - 50;
const gravity = 0.7;

const titleScreen = document.getElementById('titleScreen');
const gameOverOverlay = document.getElementById('gameOverOverlay');

const bgMusic = document.getElementById('bgMusic');
const punchSound = document.getElementById('punchSound');
const koSound = document.getElementById('koSound');
const volumeSlider = document.getElementById('volumeSlider');

const p1UltimateBtn = document.getElementById('p1-ultimate');
const p2UltimateBtn = document.getElementById('p2-ultimate');

let musicStarted = false;
let gameOver = false;

const keys = {};
const bloodParticles = [];

function startMusic() {
  bgMusic.volume = volumeSlider.value;
  bgMusic.play().catch(() => {});
  musicStarted = true;
}

volumeSlider.addEventListener('input', () => {
  const vol = parseFloat(volumeSlider.value);
  bgMusic.volume = vol;
  punchSound.volume = vol;
  koSound.volume = vol;
});

document.getElementById('playerForm').addEventListener('submit', function(e) {
  e.preventDefault();
  gameMode = document.getElementById('gameMode').value;
  aiDifficulty = document.getElementById('aiDifficulty').value;
  isAI = gameMode === "ai";

  player1Name = document.getElementById('player1Name').value.trim() || "Player 1";
  player2Name = isAI ? "AI" : (document.getElementById('player2Name').value.trim() || "Player 2");

  hideTitle();
  startMusic();
});

document.getElementById('gameMode').addEventListener('change', function () {
  const isAISelected = this.value === 'ai';
  document.getElementById('difficultyWrapper').style.display = isAISelected ? 'block' : 'none';
});

function hideTitle() {
  titleScreen.style.display = 'none';
}

function showGameOver(message) {
  gameOverOverlay.classList.add('show');
  gameOverOverlay.innerHTML = `
    <div>
      ${message}<br><br>
      <button onclick="location.reload()">🔁 Restart</button>
    </div>
  `;
  gameOverOverlay.style.display = 'flex';
}

  // === Game Classes ===
  class BloodParticle {
    constructor(x, y) {
      this.x = x + (Math.random() - 0.5) * 20;
      this.y = y + (Math.random() - 0.5) * 10;
      this.velX = (Math.random() - 0.5) * 2;
      this.velY = Math.random() * 2 + 1;
      this.alpha = 1;
      this.size = Math.random() * 3 + 2;
    }
    update() {
      this.x += this.velX;
      this.y += this.velY;
      this.velY += 0.1;
      this.alpha -= 0.02;
    }
    draw(ctx) {
      ctx.save();
      ctx.globalAlpha = this.alpha;
      ctx.fillStyle = 'red';
      ctx.beginPath();
      ctx.ellipse(this.x, this.y, this.size, this.size * 0.6, 0, 0, Math.PI * 2);
      ctx.fill();
      ctx.restore();
    }
    isDead() {
      return this.alpha <= 0;
    }
  }

  class Stickman {
    constructor(x, color) {
      this.x = x;
      this.y = ground;
      this.color = color;
      this.velX = 0;
      this.velY = 0;
      this.speed = 0.3;
      this.maxSpeed = 4;
      this.friction = 0.9;
      this.onGround = true;
      this.health = 300;
      this.stamina = 100;
      this.isPunching = false;
      this.punchProgress = 0;
      this.knockback = 0;
      this.staggerTime = 0;
      this.facing = 1;
      this.power = 0;
      this.ultimateReady = false;
      this.ultimateCooldown = 0;
    }

    gainPower(amount) {
      this.power = Math.min(this.power + amount, 100);
      if (this.power >= 100) this.ultimateReady = true;
    }

    ultimate() {
      if (!this.ultimateReady || this.ultimateCooldown > 0) return;
      this.ultimateReady = false;
      this.power = 0;
      this.ultimateCooldown = 300;

      const target = this === player1 ? player2 : player1;
      const direction = this.facing;

      if (Math.abs(this.x - target.x) < 80) {
        target.receiveHit(direction);
        target.receiveHit(direction);
      }

      for (let i = 0; i < 20; i++) {
        bloodParticles.push(new BloodParticle(target.x, target.y - 30));
      }
    }

    applyPhysics() {
      if (!this.onGround) this.velY += gravity;
      this.y += this.velY;
      this.velX += this.knockback;
      this.knockback *= 0.7;
      this.x += this.velX;
      this.velX *= this.friction;
      if (this.y >= ground) {
        this.y = ground;
        this.velY = 0;
        this.onGround = true;
      }
      this.x = Math.min(Math.max(this.x, 30), canvas.width - 30);
      this.facing = (this.x < canvas.width / 2) ? 1 : -1;
    }

    moveLeft() { if (this.staggerTime <= 0) this.velX = Math.max(this.velX - this.speed, -this.maxSpeed); }
    moveRight() { if (this.staggerTime <= 0) this.velX = Math.min(this.velX + this.speed, this.maxSpeed); }

    jump() {
      if (this.onGround && this.stamina >= 10) {
        this.velY = -12;
        this.onGround = false;
        this.stamina -= 10;
      }
    }

    punch() {
      if (this.isPunching || this.stamina < 15 || this.staggerTime > 0) return;
      this.isPunching = true;
      this.punchProgress = 0;
      this.stamina -= 15;
      this.gainPower(5);
    }

    receiveHit(direction) {
      if (this.staggerTime > 0) return;
      this.health -= 15;
      this.gainPower(10);
      this.knockback = direction * 5;
      punchSound.currentTime = 0;
      punchSound.play().catch(() => {});
    }

    recover() {
      if (!this.isPunching && this.stamina < 100) {
        this.stamina = Math.min(this.stamina + 0.4, 100);
      }
      if (this.staggerTime > 0) this.staggerTime--;
      if (this.ultimateCooldown > 0) this.ultimateCooldown--;
    }

    updatePunch() {
      if (!this.isPunching) return;
      this.punchProgress += 0.05;
      if (this.punchProgress >= 1) {
        this.isPunching = false;
        this.punchProgress = 0;
      }
    }
    
    // Stickman body and bars (unchanged for brevity)
    draw() {
  // Draw stickman
  ctx.save();
  ctx.strokeStyle = this.color;
  ctx.lineWidth = 4;
  ctx.lineCap = 'round';

  const headY = this.y - 50;
  const bodyY = this.y - 20;

  // Head
  ctx.beginPath();
  ctx.arc(this.x, headY, 12, 0, Math.PI * 2);
  ctx.stroke();

  // Body
  ctx.beginPath();
  ctx.moveTo(this.x, headY + 12);
  ctx.lineTo(this.x, bodyY);
  ctx.stroke();

  // Arms
  ctx.beginPath();
  ctx.moveTo(this.x, headY + 20);
  ctx.lineTo(this.x - 15 * this.facing, headY + 35);
  ctx.moveTo(this.x, headY + 20);
  ctx.lineTo(this.x + 15 * this.facing, headY + 35);
  ctx.stroke();

  // Legs
  ctx.beginPath();
  ctx.moveTo(this.x, bodyY);
  ctx.lineTo(this.x - 10, this.y);
  ctx.moveTo(this.x, bodyY);
  ctx.lineTo(this.x + 10, this.y);
  ctx.stroke();

  // Punch Arm
  if (this.isPunching) {
    ctx.beginPath();
    ctx.moveTo(this.x, headY + 20);
    ctx.lineTo(this.x + 25 * this.facing, headY + 10);
    ctx.stroke();
  }

  // Health bar
  const barWidth = 60;
  const healthRatio = this.health / 300;
  ctx.fillStyle = 'rgba(255, 0, 0, 0.6)';
  ctx.fillRect(this.x - barWidth / 2, this.y - 80, barWidth, 8);
  ctx.fillStyle = 'lime';
  ctx.fillRect(this.x - barWidth / 2, this.y - 80, barWidth * healthRatio, 8);

  // Power bar
  const powerRatio = this.power / 100;
  ctx.fillStyle = 'rgba(255, 255, 0, 0.6)';
  ctx.fillRect(this.x - barWidth / 2, this.y - 70, barWidth * powerRatio, 6);

  // Draw player name
  ctx.fillStyle = 'white';
  ctx.font = 'bold 14px Orbitron, sans-serif';
  ctx.textAlign = 'center';
  const name = this === player1 ? player1Name : player2Name;
  ctx.fillText(name, this.x, this.y - 95);

  ctx.restore();
}
  }

  const player1 = new Stickman(150, '#e63946');
const player2 = new Stickman(650, '#457b9d');

function setupButton(id, key, isPunch, player) {
  const btn = document.getElementById(id);
  btn.addEventListener('mousedown', e => { e.preventDefault(); keys[key] = true; if (isPunch) player.punch(); });
  btn.addEventListener('mouseup', e => { e.preventDefault(); keys[key] = false; });
  btn.addEventListener('mouseleave', e => { keys[key] = false; });
  btn.addEventListener('touchstart', e => { e.preventDefault(); keys[key] = true; if (isPunch) player.punch(); }, { passive: false });
  btn.addEventListener('touchend', e => { e.preventDefault(); keys[key] = false; }, { passive: false });
}

setupButton('p1-left', 'a');
setupButton('p1-right', 'd');
setupButton('p1-jump', 's');
setupButton('p1-punch', 'w', true, player1);
document.getElementById('p1-jump').addEventListener('mousedown', () => player1.jump());
document.getElementById('p1-jump').addEventListener('touchstart', (e) => {
  e.preventDefault(); player1.jump();
}, { passive: false });

setupButton('p2-left', 'ArrowLeft');
setupButton('p2-right', 'ArrowRight');
setupButton('p2-jump', 'ArrowDown');
setupButton('p2-punch', 'ArrowUp', true, player2);
document.getElementById('p2-jump').addEventListener('mousedown', () => player2.jump());
document.getElementById('p2-jump').addEventListener('touchstart', (e) => {
  e.preventDefault(); player2.jump();
}, { passive: false });

p1UltimateBtn.addEventListener('click', () => player1.ultimate());
p2UltimateBtn.addEventListener('click', () => player2.ultimate());

function detectHit(attacker, defender) {
  if (!attacker.isPunching) return false;
  let reach = 45;
  let armX = attacker.x + reach * attacker.facing;
  let armY = attacker.y - 20;
  return Math.abs(armX - defender.x) < 25 && Math.abs(armY - defender.y) < 30;
}

function gameLoop() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  ctx.fillStyle = '#222';
  ctx.fillRect(0, ground + 10, canvas.width, 5);

  if (gameOver) return;

  // Player input
  if (keys['a']) player1.moveLeft();
  if (keys['d']) player1.moveRight();
  if (keys['s']) player1.jump();
  if (!isAI) {
    if (keys['ArrowLeft']) player2.moveLeft();
    if (keys['ArrowRight']) player2.moveRight();
    if (keys['ArrowDown']) player2.jump();
  }

  // === AI Logic ===
  if (isAI) {
    const dx = player1.x - player2.x;
    let punchChance = 0.05;
    let jumpChance = 0.003;
    let moveThreshold = 80;
    let ultimateAggression = 1.0;

    switch (aiDifficulty) {
      case 'easy':
        punchChance = 0.03;
        jumpChance = 0.002;
        moveThreshold = 100;
        ultimateAggression = 0.3;
        break;
      case 'medium':
        punchChance = 0.07;
        jumpChance = 0.004;
        moveThreshold = 80;
        ultimateAggression = 0.7;
        break;
      case 'hard':
        punchChance = 0.15;
        jumpChance = 0.01;
        moveThreshold = 60;
        ultimateAggression = 1.0;
        break;
    }

    if (Math.abs(dx) > moveThreshold) {
      if (dx > 0) player2.moveRight();
      else player2.moveLeft();
    }

    if (Math.random() < jumpChance && player2.onGround) {
      player2.jump();
    }

    if (Math.abs(dx) < 60 && Math.random() < punchChance) {
      player2.punch();
    }

    if (player2.ultimateReady && player2.ultimateCooldown <= 0 && Math.random() < ultimateAggression) {
      player2.ultimate();
    }
  }

  // Update game objects
  player1.applyPhysics();
  player2.applyPhysics();
  player1.recover();
  player2.recover();
  player1.updatePunch();
  player2.updatePunch();

  if (detectHit(player1, player2)) {
    player2.receiveHit(player1.facing);
  }
  if (detectHit(player2, player1)) {
    player1.receiveHit(player2.facing);
  }

  player1.draw();
  player2.draw();

  // Blood particles
  for (let i = bloodParticles.length - 1; i >= 0; i--) {
    let p = bloodParticles[i];
    p.update();
    p.draw(ctx);
    if (p.isDead()) bloodParticles.splice(i, 1);
  }

  // Check for KO
  if (player1.health <= 0) {
    gameOver = true;
    showGameOver(`${player2Name} wins! 🏆`);
    koSound.play().catch(() => {});
    return;
  }
  if (player2.health <= 0) {
    gameOver = true;
    showGameOver(`${player1Name} wins! 🏆`);
    koSound.play().catch(() => {});
    return;
  }

  // Show/hide ultimate buttons
  p1UltimateBtn.style.display = player1.ultimateReady ? 'inline-block' : 'none';
  p2UltimateBtn.style.display = (player2.ultimateReady && !isAI) ? 'inline-block' : 'none';

  requestAnimationFrame(gameLoop);
}

// Keyboard bindings
window.addEventListener('keydown', e => {
  keys[e.key] = true;
  if (e.key === 'w') player1.punch();
  if (e.key === 'ArrowUp') player2.punch();
  if (e.key === 'q') player1.ultimate();
  if (e.key === '/') player2.ultimate();
});

window.addEventListener('keyup', e => {
  keys[e.key] = false;
});

// Start loop
gameLoop();
</script>
</body>
</html>